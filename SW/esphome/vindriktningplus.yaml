substitutions:
  # pinout
  FAN_PIN: GPIO0
  BUZZER_PIN: GPIO1
  WS2812_PIN: GPIO2
  BRIGHT_PIN: GPIO3
  PM_TX_PIN: GPIO4
  PM_RX_PIN: GPIO5
  IR_REC_PIN: GPIO6
  I2C_SCL: GPIO7
  I2C_SDA: GPIO8
  # BOOT_PIN: GPIO9
  INT_LED_PIN: GPIO10
  # default values
  SCD4x_update_interval: 60s
  temp_calibration: "-4"
  ADC_update_interval: 60s
  pm1006_update_interval: 60s
  # limit values
  aqi_co2_ideal_good: "600"
  aqi_co2_max_good: "800"
  aqi_co2_ideal_acceptable: "1000"
  aqi_co2_max_acceptable: "1200"
  aqi_pm2_5_avg_24h_max_good: "12"
  aqi_pm2_5_avg_24h_max_acceptable: "25"  # WHO 2006
  aqi_message_bad: "Bad"
  aqi_message_acceptable: "Acceptable"
  aqi_message_good: "Good"

globals:
  - id: pm_min
    type: float
    initial_value: '300.0'
  - id: pm_max
    type: float
    initial_value: '0.0'
  - id: co_min
    type: float
    initial_value: '5000.0'
  - id: co_max
    type: float
    initial_value: '0.0'
  - id: temp_min
    type: float
    initial_value: '50.0'
  - id: temp_max
    type: float
    initial_value: '0.0'

esphome:
  name: vindriktningplus
  friendly_name: VindriktningPlus
  on_boot:
    then:
      - lambda: 'id(pm2_5).publish_state(1.0);'
      - lambda: 'id(co2).publish_state(400);'
      - light.turn_on:
          id: status_led
          brightness: !lambda return id(led_brightness).state;
          effect: "Boot Pulse"
      - wait_until:
          timeout: 30s
          condition:
            and:
              - wifi.connected:
              - api.connected:
      - light.turn_off: status_led
      - script.execute: min_max_zero_script

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable bluetooth proxy
# bluetooth_proxy:
#   active: true

# Enable Home Assistant API
api:
  encryption:
    key: !secret vindriktingplus_api
  services:
    - service: play_rtttl
      variables:
        song_str: string
      then:
        - rtttl.play:
            id: rtttl_module
            rtttl: !lambda 'return "song_str";'

ota:
  password: !secret vindriktingplus_ota

wifi:
  networks:
    ssid: !secret wifi_ssid
    password: !secret wifi_password
    hidden: true

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Vindriktningplus"
    password: "Vindriktningplus"

captive_portal:

substitutions:
  pos-latitude: "48.210033°"
  pos-longitude: "16.363449°"

number:
  # LED brightness in day mode (in percent)
  - platform: template
    id: led_brightness
    name: "Led Brightness"
    min_value: 0
    max_value: 100
    step: 1
    optimistic: True
    restore_value: True
    on_value:
      then:
        - lambda: id(status_led).remote_values.set_brightness(id(led_brightness).state/100);

  # LED brightness in night mode (in percent)
  - platform: template
    id: led_night_mode
    name: "Led Night Brightness"
    min_value: 0
    max_value: 100
    step: 1
    optimistic: True
    restore_value: True

  # PM1006 fan speed in percent
  - platform: template
    id: pm1006_fan_speed
    name: "PM1006 Fan Speed"
    min_value: 0
    max_value: 100
    step: 1
    optimistic: True
    restore_value: True
    on_value:
      then:
        - lambda: id(pm1006_fan_ctrl).speed  = id(pm1006_fan_speed).state;

select:
  # switch between three predefined fan modes for the PM1006 fan
  - platform: template
    name: "PM1006 measurment mode"
    id: pm1006_mode
    options:
      - "Fan automatic mode"
      - "Fan always on"
      - "Fan manual mode"
    initial_option: "Fan automatic mode"
    optimistic: True

button:
  # Button to force an measuremnt cycle for the PM1006
  - platform: template
    name: "Force PM1006 measurement"
    on_press:
      then:
        - script.execute: pm1006_measurement_script
  # Reset measurement values
  - platform: template
    name: "Reset min/max values"
    on_press: 
      then:
        - script.execute: min_max_zero_script

switch:
  # pseudo sensor to switch between day and night mode
  #   night mode deactivats the PM1006 measurements, since the fan has to run
  - platform: template
    name: "Night Mode"
    id: night_mode
    publish_initial_state: True

# uart used for PM1006 exclusively
uart:
  rx_pin: $PM_TX_PIN
  tx_pin: $PM_RX_PIN
  baud_rate: 9600
  id: uart_a

# main i2c bus
i2c:
  scl: $I2C_SCL
  sda: $I2C_SDA
  id: bus_a
  frequency: 100kHz

text_sensor:
  # ESPHome version string
  - platform: version
    name: ${device_name} ESPHome Version
  # fancy wifi information
  - platform: wifi_info
    ip_address:
      name: ${device_name} IP
    ssid:
      name: ${device_name} SSID
    bssid:
      name: ${device_name} BSSID

sensor:
  # board uptime
  - platform: uptime
    name: ${device_name} Uptime
  # WiFi signal information
  - platform: wifi_signal
    name: ${device_name} WiFi Signal
    update_interval: 60s
  # The PM1006 particle sensor in the Vindrikting
  - platform: pm1006
    uart_id: uart_a
    id: pm1006_module
    internal: never
    pm_2_5:
      internal: True
      id: _pm1006_pm_2_5

  # PM2.5 sensor which'll get updated by interval
  - platform: template
    name: "Particulate Matter 2.5µm Concentration"
    id: "pm2_5"
    unit_of_measurement: "µg/m³"
    icon: "mdi:blur"
    on_value: 
      then:
          - lambda: |-
              // configs
              // WHO2015: AQI Concentration Breakpüoints by Pollutant 
              constexpr std::array<std::tuple<uint16_t,uint16_t, Color>, 6> ranges = {
                  {0, 12, Color(0x00, 0x99, 0x66)}, // green
                  {12, 35, Color(0xff, 0xde, 0x33)}, // yellow
                  {35, 55, Color(0xff, 0x99, 0x33)}, // orange
                  {55, 150, Color(0xcc, 0x00, 0x33)}, // red
                  {150, 250, Color(0x66, 0x00, 0x99)} // violette
                  {250, numeric_limits<uint16_t>::max(), Color(0x7e, 0x00, 0x23)} // deep red
                }; 
              auto led = id(led1).turn_on();
              // execute the led coloring
              const auto val = id(co2).state;
              for(const auto &e: ranges) {
                  const auto [lower, upper, color] = e;
                  if(sensor_value >= lower && sensor_value < higher) {
                    led.set_rgb(color.r, color.g, color.b);
                    led.perform();
                    break;
                  }
              }
        - lambda: |-
            // update min & max
            const auto cval = id(pm2_5).state;
            if(cval > id(pm_max)) {
              id(pm_max) = cval;
            } else if(cval < id(pm_min)) {
              id(pm_min) = cval;
            }

  # PM 2.5 24h average
  - platform: template
    name: "PM2.5 24h average"
    id: pm2_5_avg
    icon: mdi:chemical-weapon
    unit_of_measurement: µg/m³
    lambda: |-
      return id(pm_2_5).state;
    update_interval: 60s
    filters:
      - sliding_window_moving_average:
          window_size: 1440
          send_every: 1
    on_value: 
      then:
          - lambda: |-
              // configs
              // WHO2015: AQI Concentration Breakpüoints by Pollutant 
              constexpr std::array<std::tuple<uint16_t,uint16_t, Color>, 6> ranges = {
                  {0, 12, Color(0x00, 0x99, 0x66)}, // green
                  {12, 35, Color(0xff, 0xde, 0x33)}, // yellow
                  {35, 55, Color(0xff, 0x99, 0x33)}, // orange
                  {55, 150, Color(0xcc, 0x00, 0x33)}, // red
                  {150, 250, Color(0x66, 0x00, 0x99)} // violette
                  {250, numeric_limits<uint16_t>::max(), Color(0x7e, 0x00, 0x23)} // deep red
                }; 
              auto led = id(led2).turn_on();
              // execute the led coloring
              const auto val = id(co2).state;
              for(const auto &e: ranges) {
                  const auto [lower, upper, color] = e;
                  if(sensor_value >= lower && sensor_value < higher) {
                    led.set_rgb(color.r, color.g, color.b);
                    led.perform();
                    break;
                  }
              }

  # This is a "helper" template sensor which is doing 30 sec moving average of PM2.5
  - platform: template
    name: "PM2.5 median"
    id: pm2_5_median
    icon: mdi:chemical-weapon
    unit_of_measurement: µg/m³
    lambda: |-
      return id(pm2_5).state;
    update_interval: 1s
    filters:
      - median:
          window_size: 30
          send_every: 30
          send_first_at: 15

  # CO2, temperature & humidity sensor
  - platform: scd4x
    i2c_id: bus_a
    co2:
      name: "CO2"
      id: co2
      on_value: 
        then:
          - lambda: |-
              // configs
              constexpr std::array<std::tuple<uint16_t,uint16_t, Color>, 5> ranges = {
                  {0,    700, Color(0x00, 0x99, 0x66)},  // green
                  {700,  1000, Color(0xff, 0xde, 0x33)}, // yellow
                  {1000, 1500, Color(0xff, 0x99, 0x33)}, // orange
                  {1500, 2100, Color(0xcc, 0x00, 0x33)}, // red
                  {2100, numeric_limits<uint16_t>::max(), Color(0x66, 0x00, 0x99)} // violette
                }; 
              auto led = id(led3).turn_on();
              // execute the led coloring
              const auto val = id(co2).state;
              for(const auto &e: ranges) {
                  const auto [lower, upper, color] = e;
                  if(sensor_value >= lower && sensor_value < higher) {
                    led.set_rgb(color.r, color.g, color.b);
                    led.perform();
                    break;
                  }
              }
          - lambda: |-
              // update min & max
              const auto cval = id(co2).state;
              if(cval > id(co2_max)) {
                id(co2_max) = cval;
              } else if(cval < id(co2_min)) {
                id(co2_min) = cval;
              }              
    temperature:
      name: "Temperature"
      id: temperature
      on_value: 
        then:
          - lambda: |-
              // update min & max
              const auto cval = id(temperature).state;
              if(cval > id(temp_max)) {
                id(temp_max) = cval;
              } else if(cval < id(temp_min)) {
                id(temp_min) = cval;
              }
    humidity:
      name: "Humidity"
      id: humidity
    measurement_mode: low_power_periodic
    update_interval: $SCD4x_update_interval
    temperature_offset: $temp_calibration

  # - platform: bme280
  #   i2c_id: bus_a
  #   temperature:
  #     name: "BME280 Temperature"
  #     id: temperature
  #   humidity:
  #     name: "BME280 Humidity"
  #     id: humidity
  #   pressure:
  #     name: "BME280 Pressure"
  #     id: pressure
  #   update_interval: 60s

  # calculate the absolute humidity
  - platform: absolute_humidity
    name: "Absolute Humidity"
    temperature: temperature
    humidity: humidity

  # Phototransistor
  - platform: adc
    pin: $BRIGHT_PIN
    name: Illuminance
    unit_of_measurement: lux
    internal: $ADC_update_interval
    filters:
      - sliding_window_moving_average:
          window_size: 15
          send_every: 15
      - lambda: |-
          return (x * 3.3 / 10000.0) * 2000000.0;

output:
  - platform: ledc
    pin: $FAN_PIN
    frequency: 25kHz
    id: pm1006_fan
    channel: 0
  - platform: ledc
    pin: $BUZZER_PIN
    channel: 2
    id: buzzer_out

fan:
  - platform: speed
    name: "PM1006 Fan"
    output: pm1006_fan
    id: pm1006_fan_ctrl
    speed_count: 100

remote_receiver:
  pin: $IR_REC_PIN
  dump: all

rtttl:
  output: buzzer_out
  id: rtttl_module

light:
  - platform: partition
    name: LED 1
    id: led1
    default_transition_length: 0s
    segments: 
      - id: rgb_led
      from: 0
      to: 0
  - platform: partition
    name: LED 2
    id: led2
    default_transition_length: 0s
    segments: 
      - id: rgb_led
      from: 1
      to: 1
  - platform: partition
    name: LED 3
    id: led3
    default_transition_length: 0s
    segments: 
      - id: rgb_led
      from: 2
      to: 2
  - platform: esp32_rmt_led_strip
    pin: GPIO2
    rgb_order: GRB
    num_leds: 3
    rmt_channel: 0
    chipset: WS2812
    name: "Status LEDs"
    id: rgb_led
    default_transition_length: 0s
    on_turn_on:
      - then:
          - light.turn_on:
              id: rgb_led
              brightness: !lambda |-
                const auto val = id(night_mode).state ? id(led_night_mode).state : id(led_brightness).state;
                return float(val) / 100;

    effects:
      # pulsing light for boot-up until we the unit is connected to wifi
      - pulse:
          transition_length: 1s
          update_interval: 1s
          name: "Boot Pulse"

status_led:
  pin: $INT_LED_PIN

# optional lcd
# font:
#   - file: "gfonts://Roboto"
#     id: roboto
#     size: 10

# display:
#   - platform: ssd1306_i2c
#     model: SSD1306_128X32
#     id: mini_display
#     pages:
#       - id: page1
#         lambda: |-
#           it.printf(5, 10, id(roboto), "PM2.5 %0.2f µg/m³", id(pm_2_5).state);
#           it.printf(5, 15, id(roboto), "Temperature: %0.2f °C", id(scd4x_temperature).state);
#           it.printf(5, 20, id(roboto), "Humidity: %0.2f %", id(scd4x_humidity).state);
#       - id: page2
#         lambda: |-
#           it.strftime(10, 15, id(roboto), "%Y-%m-%d %H:%M", id(ha_time).now());

script:
  - id: pm1006_measurement_script
    mode: single
    then:
      - fan.turn_on:
          id: pm1006_fan_ctrl
          speed: !lambda "return id(pm1006_fan_speed).state;"
      - delay: 20s
      - component.update: pm1006_module
      - sensor.template.publish:
          id: pm2_5
          state: !lambda |-
            return id(_pm1006_pm_2_5).state;
      - delay: 200ms
      - fan.turn_off: pm1006_fan_ctrl
  - id: min_max_zero_script
    then: 
      - globals.set:
          id: pm_max
          value: '0.0'
      - globals.set:
          id: pm_min
          value: '300.0'
      - globals.set:
          id: co_max
          value: '0.0'
      - globals.set:
          id: co_min
          value: '5000.0'
      - globals.set:
          id: temp_min
          value: '50.0'
      - globals.set:
          id: temp_max
          value: '0.0'

sun:
  latitude: ${pos-latitude}
  longitude: ${pos-longitude}
  on_sunrise:
    then:
      - if:
          condition:
            - not:
                - api:
          then:
            - switch.turn_off: night_mode
  on_sunset:
    then:
      - if:
          condition:
            - not:
                - api:
          then:
            - switch.turn_on: night_mode

interval:
  - interval: $pm1006_update_interval
    id: pm1006_measurement
    then:
      - if:
          condition:
            - binary_sensor.is_off: night_mode
          then:
            - script.execute: pm1006_measurement_script

time:
  - platform: homeassistant
    id: ha_time
  - platform: sntp
    id: sntp_time
    update_interval: 60min
